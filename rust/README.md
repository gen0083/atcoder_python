競技プログラミング with Rust
===

[オフィシャルドキュメント](https://doc.rust-lang.org/book/title-page.html)

[VSCode拡張について](https://tech-blog.optim.co.jp/entry/2019/07/18/173000)

### Kotlin使ってたときの癖でよくやりがち。

- 行末にセミコロンつけ忘れ
- ifのコンディションには`()`不要
- でもtrue/elseのブロックの`{}`は必須（中身が一行でも要る）
- inputマクロを使う際に各行をセミコロンで区切りがち(ここは`,`)
- `.parse()`でString->numへの変換を行う前に`.trim()`忘れがち

## AtCoderをRustでやるのに便利なツール

### proconio

[proconio](https://docs.rs/proconio/0.4.3/proconio/)

標準入力の読み込みが簡単に定義できる。

### cargo-compete

[cargo-compete](https://github.com/qryxip/cargo-compete)

問題用のディレクトリ作成、サンプルテストケースを自動的に取り込んだり、参加登録とかもできる。ブラウザなくてもsubmitできる。便利。

`cargo new <コンテストID>`でコンテスト用のディレクトリを作成。コンテストIDはコンテストのURLの末尾。

作成されたディレクトリに移動し、`cargo test <問題>`で該当のテストを実行(`cargo test a`など)。

`cargo compete submit`で該当の問題を提出。提出前にテストが実行されるので、`cargo compete test`はやらなくてもよい。

#### toolchainのバージョン

AtCoderでは`1.42.0`が使われるが、このバージョンだとApple silliconで`cargo`が動かない。そのため自環境で動いている`1.53.0`を使うようにした。

## Rustについて

[オーナーシップ](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)

スタックとヒープの違いを意識する
（スタックにはコンパイル時にサイズが判明しているものなら詰めるけれど、そうでないものはヒープでメモリの割当が必要とかそういう話）
プリミティブタイプはスタックに積めるけど、そうでないものはヒープに確保→そのメモリアドレスへのポインタがスタックに積まれる（ポインタについてはサイズが判明してるからスタックに積める）

Stringについて
リテラルとStringタイプは違う（"hoge"はリテラルでイミュータブル。String::from("hoge")だとこれはミュータブルで）

deep copyを明示的にしたい場合は`clone()`を使う。そうしない場合はmove
shallow copyとは違って、次のようなコードの場合、`s`はmoveされた段階で値に対するownerではなくなるので、その後のコードで`s`へのアクセスはコンパイルエラーになる。

```rust
let s = String::from("abcdefg");
let t = s;
println!("{}", t); // これはオッケー
println!("{}", s); // これはNG
```

これは`String`だからそうなる。これが`i32`などの場合、Copyトレイトが実装されているので、同じようなコードでもmoveではなくcopyが行われ、scopeを抜けるまではどちらも正しく値にアクセスできる。

この仕組はfunctionの呼び出しでも同じで、何らかの関数に値を渡した段階でmoveが発生し、関数呼び出し後には値にアクセスできなくなる。

```rust
let s = String::from("hoge");
some_function(s);
println!("{}", s); // NG sはsome_functionにmoveされてる
```

## Reference / Borrowing

オーナーシップの概念があるので、functionに値を渡したあとにその値を再利用したい場合、function内で利用した引数も返してやる必要がある。
もしくはreferenceを利用する。

Rustを使っていて関数に`&str`を要求されてるのはなんでかなと思ったらこのためのようだ。

値として利用はしたいが、オーナーシップはそのままにしておきたいときにリファレンスを使えばいい。オーナーシップを奪うことなく値の利用ができる。

functionの引数にreferenceを使うことをbrrowingというらしい。

基本的にreferenceはimmutable。借り物なのだから勝手に変更するな、ということだろう。変更してもいいなら`some_function(&mut hoge)`のように`&mut`をつければよい。

ただし`&mut`リファレンスは1つだけという制約がある。（同一スコープ内で同一データに対する`&mut`リファレンスは1つしか許可されない）

```rust
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s; // r1でmut refferenceが作成されているのでこれはコンパイルが通らない
```

さらには`&mut`と`&`の参照は同時にできない。（`&`のみのimmutableな参照についてはいくつでもできる）

## slice

スライスもリファレンスと同様オーナーシップをもたないデータタイプ。

sliceはimmutableなリファレンス。StringリテラルはStringのスライスになる。`&str`はStringのスライス（＝Stringリテラル）を表し、`&String`にも`&str`にも使える表記。
`hoge[0]`のように配列に添え字でアクセスするのもスライス。
スライスは範囲指定もできるので`hoge[4..10]`みたいな一部を切り出す（切り出してるんじゃなくて借りてるんだけども）こともできる。

## struct

[struct](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)

tupleに各フィールドに名前をつけたようなもの。

```rust
struct User {
	name: String,
	age: usize,
}

let user = User {name: "hoge", age: 12};
```

structのインスタンス生成にはストラクト名と`{}`で区切って各値を設定する。フィールド名と与える値の変数名が同じなら省略できる。

```rust
let name = "hoge";
let age = 12;
let user = User {name, age};
```

フィールドはstructで定義されたものがすべて充足されていれば良い。指定する順番は異なっていても、そのすべてが指定されていれば問題ない。
別のインスタンスの値をそのまま利用する場合、`..`をつけて他のフィールドについては指定したインスタンスのデータを使うことができる。

structの定義には名前をつけずにtupleのように宣言することも可能。`struct Hoge(i32, i32, String);`みたいに定義もできる。(tuple struct)
この場合フィールド名がない。値にアクセスするには`Hoge.0`のようにインデックスを使う。

structは常にmutable扱い。特定のフィールドのみmutableにしたい（ほかはimutableにしたい）というのはできない。

tupleはデータの型しかみないが、tuple structだとフィールドのデータ型がすべて一致していてもstructが違えば別物として扱われる。`struct A(i32, i32)`と`struct B(i32, i32)`はどちらも`i32`を2つもつデータだが、だからといってAを要求するところにBは入らない。tupleだとその区別はされないのが違いかな？

structに関数を定義するのはなんかPythonチックなイメージを持った。
struct宣言内にはメソッドを定義できない。メソッドの定義はimplブロックで行う。

```rust
impl User {
	fn is_adult(&self) -> bool {
		self.age > 20
	}

	fn is_friend_of(&self, other: &User) -> bool {
		self.favorite == other.favorite	
	}
	// ちなみにimplブロックを分けて定義してもよい
	// それが便利なケースもあるらしい
}
```

基本的に`&self`を引数に取る関数を定義していく。`&self`のない関数も定義できる。それはそのstructの名前空間に関連付けられたメソッドとして扱われる。その場合`User::some_function()`のように`::`をつけて呼び出す形になる。

`#[derive(Debug)]`のようにstruct定義の前にアノテーションをつけると、`()`内で指定したトレイトがそのstructで使えるようになる。`Debug`は`println!("{:?}", hoge);`のように`{:?}`で出力する際に利用されるもの。

## enum

structのようなもの。

Rustの`Option<T>`はenumだった。nullのかわりに`None`が使われていて、`Option<T>`が`Some(T)`もしくは`None`になる。
Kotlinでいえば`T?`に近いということだろう。`unwrap()`はKotlinでいうところの`!!`演算子みたいなもんてことかな。

```rust
if let Some(user) = find_user_by_id(id) {
	println!("find user {:?}", user);
} else {
	println!("user not found");
}
```

みたいな書き方ができる。Kotlinの`user?.let {}`っぽい。

```rust
let match num.cmp(&0) {
	std::cmp::Ordering::Less => println!("0"),
	_ => println!("{}", num)
}
```

matchで比較する場合にenumはすべて列挙しないといけないが、`_`を使えばKotlinのwhen式でいうところの`else`みたいな役割をしてくれる。

## match

Kotlinでいうところの`when`みたいなもの。enumと組み合わせて使う場合、全パターンを網羅してないとだめ。コンパイラが実装漏れがあれば教えてくれるってこと。

Kotlinの`when`における`else`のように、全パターン列挙せずいずれも該当しない場合を表したいときは`_`を使う。

## collection

```rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6);
println!("The first element is: {}", first);
```

なんでこれでエラーになるのか、配列の先頭を参照してるだけで、その後ろに値を追加するのは影響ないじゃんとか思ってた。しかしメモリ上に要素を追加するのに十分な領域がない場合、別の領域に新たに配列が収まる領域を確保してそっちに移動する可能性がある。そうした場合は先頭へのポインタが値の追加によって無効になる可能性がある。

## 文字列

[文字列](https://doc.rust-jp.rs/book-ja/ch08-02-strings.html)

Rustでは文字列と言えば`String`か`&str`を指す。所有権をもつかもたないかの違い。

Rustでは文字列の添字アクセスはできない。

```rust
let name = String::from("jhon");
println!("first letter = {}", &name[0]);
```

Rustは文字列をUTF-8で扱う。そのためその文字が1バイトか2バイトか添字だけではわからない。だから添字アクセスできない。添字アクセスできないが、範囲でのアクセス（スライス）は可能。もしくはCharのベクタとして用意してアクセスするなど。

## HashMap

[HashMap](https://doc.rust-jp.rs/book-ja/ch08-03-hash-maps.html)

文字の出現回数をHashMapを使ってカウントする処理は次のようにかける。

```rust
for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
```

`entry(key).or_insert(default)`で該当のkeyがあればその参照を、なければデフォルトの値でkeyを作成しその参照を取得という処理になる。
その結果、その参照を使って値を更新すればよい。

## エラーハンドリング

[エラーハンドリング](https://doc.rust-jp.rs/book-ja/ch09-02-recoverable-errors-with-result.html)

Rustでも`?`演算子があって、Kotlinのようにメソッドチェーン中に使うことができる。
Kotlinだとnullになりうる場合に、nullじゃなければ続きの処理が走ってnullなら止まるという動きをする。
Rustでは`Result<T, E>`に対して?演算子を用いる。この場合、Eの方が来たときに早期リターンを行う動きになる。
そのため?演算子はResultを返す関数内でしか使用できない。

## ジェネリクス

Rustではジェネリクスを使ったコードはコンパイル時にいい感じにするので、実行時のパフォーマンスが悪くなることはない。
ジェネリクスよりもコード生成が主流なAndroidの感覚で言えば、アノテーションによるコード生成がRustにおけるジェネリクスとも言えるかもしれん。

## トレイト

[trait](https://doc.rust-jp.rs/book-ja/ch10-02-traits.html)

Kotlin/Javaでいうところのinterface的なもの。
interfaceよりも共通の振る舞いをするものを定義したものがトレイトなのだろうか。

interfaceは実装を強制する効果があるけれど、トレイトにはそれはないのが違うところか。

## ライフタイム

[ライフタイム](https://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html)

参照にはすべてライフタイムが存在する。基本的には推論が働いていい感じに処理してくれる。

ライフタイムの主な目的がダングリング参照（ある場面では有効だったメモリへの参照が、その後において無効になってしまうこと。Rustではイミュータブルな借用が行われている間はミュータブルな借用を確保できないなどもこれの回避を目的としている）の回避。

いまいちブロックのスコープと何が違うのかよくわからん。

例えばある関数について、2つの参照を渡して何らかの条件でどちらかの参照が返ってくるものがあるとする。するとここで渡した2つの参照はコンパイル時点ではどっちが返ってくるのかわからない（というか条件によって変わるのだからどっちが返ってくるとは言えない）

すると片方の参照は関数に渡った時点で借用が終了するが、もう片方は継続することになる。するとどこまでライフタイムを追えばよいのかコンパイラがわからなくなってRustの制約が守れなくなる。そういう場合にライフタイムを明示しなさいというルールがあるということか。

`&'a i32`みたいな表記をするのがライフタイム注釈記法。この注釈がついている参照は、どれも同じだけの長さのライフタイムを持つ、というのがコンパイラに伝わる。

関数に渡ってくる参照について、その参照がどこまで有効な参照かを明示する目的でつけるが基本っぽい？
あとは関数で参照を返すときにこの問題が出てくるっぽい。
関数内で生成した参照を返す、というのは単純にコンパイルエラーになる。（関数のスコープが終了した時点でその値が無効になるから）

## テスト

[テスト](https://doc.rust-jp.rs/book-ja/ch11-03-test-organization.html)

単体テストはテスト対象と同じファイルに書くことができる。慣習的には同じファイルにtestsモジュールを作ってそこにテストコードを書く。

`#[cfg(test)]`というアノテーションをつける。これによって、そのモジュールはbuild時にではなくtestのときだけコンパイルされる。だから同じファイルにテストコードも一緒に書ける。

testsディレクトリには結合テストを書く。

## クレート/モジュール

パッケージはなんとなくわかる。`cargo new`でつくったのがパッケージ。gradleでいうところのプロジェクトがそれに該当するのかな（ちょっと違いそうだけど、マルチモジュール構成のルートプロジェクトがパッケージみたいな？）。

モジュールは`mod`で宣言したもの。

ではクレートは？

パッケージは1つ以上のクレートからなるらしい。

クレート＝ファイルではなさそう。いくつかのファイルがまとまって1つのクレートを構成することもあるんだろう。

クレートにはバイナリクレートとライブラリクレートがあるらしい。`src/main.rs`はパッケージと同じ名前を持つバイナリクレート、`src/lib.rs`があればそれはパッケージ名と同じライブラリクレート。

`src/bin`にファイルを配置したら、それぞれのファイルが別のバイナリクレートとなるらしい。

[モジュールツリー](https://doc.rust-jp.rs/book-ja/ch07-02-defining-modules-to-control-scope-and-privacy.html)

`src/main.rs`と`src/lib.rs`は`crate`というモジュールを形成するからクレートルートと呼ばれる。つまりモジュールツリーのルートは常に`crate`ということになる。`mod`でモジュールを宣言していくと、その`crate`の下にモジュールが追加される。モジュールの中にモジュールを定義していけばさらに階層構造ができる。

https://doc.rust-jp.rs/book-ja/ch07-05-separating-modules-into-different-files.html

## イテレータ

[イテレータ](https://doc.rust-jp.rs/book-ja/ch13-02-iterators.html)

順繰りに要素をみていくイテレータだけども、Rustではどちらかというとストリームと考えたほうがよいのかも。そう言われるとなんかしっくり来る箇所がちらほらある(`.collect()`を最後に呼び出してたりするのが気になってた)。

遅延評価ということになるのか。`iter()`を呼んだだけではなんの処理も行われない。



## Rustの特性について思ったこと

Rustがスレッドセーフとかメモリリークと無縁みたいなことが言われるのは、言語仕様としてそれらが発生しないような制約をかけてるってこと。
Kotlinがnullsafetyを謳っているのと感覚的に同じと考えると納得がいく。
scopeを抜けたらそのscope内で確保されていたメモリが開放されるとか（この書き方が正確かはまだよくわかってないが）。
別の変数にデータを再代入させたらもとの変数は即座に無効になるとか。
その制約下ではコードを書くのが大変だからリファレンスという仕組み（ポインタ）があるけど、基本的には読み取りしかできない。変更可能なようにするには`&mut`（変数なら`mut`）をつけて明示しないといけないとか。
`&mut`を使えばオーナーシップがなくても値を書き換えられるけど、それができるのは1つだけとか。（あっちでもこっちでも書き換えできるようにはならない）
そういうのがすべてコンパイル時に制約として乗っかってるので、安全性が確保できるってことらしい。
なるほど。

そもそもメモリ上のデータが主役と考えるとよいのかもしれない。
だからこそ「変数に束縛」という用語が出てくるわけで。
メモリを意識しなくてもよい作りになっているが、その実主役はメモリ上のデータ。データがあって、私の所有者は1つしか存在しない、というそんな仕組み。
これまで変数の方をメインで考えていたように思うので、そこが違和感につながるのかなと思った。

