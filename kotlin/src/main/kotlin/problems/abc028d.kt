fun main(args: Array<String>) {
    abc028d()
}

fun abc028d() {
    val (n, k) = readLine()!!.split(" ").map { it.toLong() }
    // 中央値がkになるということは、少なくとも1回はkが出る必要がある
    // その上で残り2回について
    //  1. kより小さい＋kより大きい
    //  2. kと任意の数（ただしk自身は除く→後述）
    // の組み合わせであれば中央値がkとなる
    // 1.は式として表せば k - 1（kより小さい）* n - k（kより大きい）
    // 小さい＋大きい　と　大きい＋小さい　は別の組み合わせであるからこれを2倍すればよい
    // 2.はn-1とする（ここでk自身を除いているのは、kを含めてしまうと3つすべてがkということになるから）
    // この組み合わせは順番を入れ替えて3パターンありうるので、最後に3倍する（今回の場合は順序は関係ないから）
    //
    // 3パターンあるので3倍するためには、3パターン存在しないすべてkの組み合わせは除いて最後に＋1してやればよい
    // これで中央値がkとなる組み合わせの個数が求められた
    // 最後にこの組み合わせの数を、総出現パターンであるn^3で割れば答えが求まる
    val a = (k - 1) * (n - k) * 2 + n - 1
    val c = a * 3 + 1
    println(c / Math.pow(n.toDouble(), 3.0))
}