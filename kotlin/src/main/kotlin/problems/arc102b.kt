// https://atcoder.jp/contests/arc102/tasks/arc102_b
// TODO: たまには難問に挑戦するのもいい・・・けど、いきなり青は難しすぎるんじゃないか、せめて水色にしようぜ

fun main() {
    arc102b()
}

fun arc102b() {
    val l = readLine()!!.toLong()
    // 素因数分解まではしなくてよいのか
    // Lを因数分解して、因数が19個以下(頂点数を20個以下にするので、頂点を結ぶパスの数は19種類が限度)、
    // 因数の和が60以下になる組み合わせを求める
    // この組み合わせが求まれば、後は各辺に長さを割り当てれば良い
    // 割り当て方は末端から0,1,2,3...末端に割り当てられた約数
    // その1つ上のパスが、0,末端の約数、^2,^3...という感じ
    // あとはそれを出力すれば答えが出る
    
    // ところで、仮に約数が19種類を超える、もしくは約数の和が60を超えるものしかできない場合はどうする？
    // たとえば素数なんかが該当すると思う
    // 巨大な素数であれば約数の種類は2だが、約数の和は60に収まらない
    println(isPrime(l))
}

private fun isPrime(n: Long): Boolean {
    var t = n
    if (t < 2) return false
    var i = 2
    while (i * i <= t) {
        if (t % i == 0L) return false
        i++
    }
    return true
}